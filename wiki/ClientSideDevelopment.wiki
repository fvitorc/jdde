#summary Client side development of DDE applications.
#labels Featured

= Introduction =

_missing_

= Conversation Management =

_missing_

== Identifying conversation disconnects ==

If you need to identify when a conversation has been disconnected you can register a `ClientDisconnectListener` like this:

{{{
String service, topic;

...

DdeClient client = new DdeClient();
ClientConversation conv = client.connect(service, topic);
conv.setDisconnectListener(new ClientDisconnectListener() {
	public void onDisconnect(ClientDisconnectEvent e) {
		...
		// do whatever you want when conversation is disconnected
	}
});
}}}

= Transaction Management =

After establishing a conversation with a server, a client can send transactions to obtain data and services from the server. These transactions are listed below.

== Request Transaction ==

A client application can use the *Request Transaction* to request a data item from a server application.

{{{
String service, topic, item;

...

DdeClient client = new DdeClient();
ClientConversation conv = client.connect(service, topic);
byte[] data = conv.request(item);
}}}

There is also an overloaded method that allows you to specify the clipboard format and timeout of the transaction. If the server does not process this transaction, it will throw a `DmlError.NOTPROCESSED` exception.

== Poke Transaction ==

A client can send unsolicited data to a server by sending the *Poke Transaction* to a server application.

{{{
String service, topic, item;
byte[] data;

...

DdeClient client = new DdeClient();
ClientConversation conv = client.connect(service, topic);
conv.poke(item, data);
}}}

There is also an overloaded method that allows you to specify the clipboard format and timeout of the transaction. If the server rejected the transaction, a `DmlError.NOTPROCESSED` will be thrown. If the server was too busy to answer the transaction, you will get a `DmlError.BUSY` exception. In this last case, the client should send the transaction again later.

== Advise Transaction ==

A client application can use the *Advise Transaction* to establish one or more links to items in a server application. When such a link has been established, the server sends periodic updates about the linked item to the client (typically, whenever the value of the item associated with the server application changes). Linking establishes an advise loop between the two applications that remains in place until the client ends it.

{{{
String service, topic, item;

...

DdeClient client = new DdeClient();
ClientConversation conv = client.connect(service, topic);

Advise advise = conv.startAdvise(item, new AdviseDataListener() {

	@Override
	public void valueChanged(AdviseDataEvent event) {
		byte[] data = event.getData();
		...
	}

});

// receive data for 10 seconds
Thread.sleep(10000);

// stop the advise transaction
advise.stop();

// it is also possible to get the last value received
byte[] data = advise.getLastValue();
}}}

There is also an overloaded method that allows you to specify the clipboard format and timeout of the transaction. If the server rejected the transaction, a `DmlError.NOTPROCESSED` will be thrown.

== Execute Transaction ==

A client can use the *Execute Transaction* to cause a server to execute a command or a series of commands.

{{{
String service, topic, command;

...

DdeClient client = new DdeClient();
ClientConversation conv = client.connect(service, topic);
conv.execute(command);
}}}

There is also an overloaded method that allows you to specify the timeout of the transaction. If the server rejected the transaction, a `DmlError.NOTPROCESSED` will be thrown. If the server was too busy to answer the transaction, you will get a `DmlError.BUSY` exception. In this last case, the client should send the transaction again later.